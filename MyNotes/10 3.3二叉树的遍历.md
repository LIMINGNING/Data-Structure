## 3.3.1先序后序中序遍历
（1）先序遍历

遍历过程为：
1. 访问根节点
2. 先序遍历其左子树
3. 先序遍历其右子树
```C
void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        printf("%d",BT->Data);  /* 先序遍历根节点 */
        PreOrderTraversal(BT->Left);
        PreOrderTraversal(BT->Right);
    }
}
```
（2）中序遍历

遍历过程为：
1. 中序遍历其左子树
2. 访问根节点
3. 中序遍历其右子树
```C
void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        PreOrderTraversal(BT->Left);
        printf("%d",BT->Data);  /* 先序遍历根节点 */
        PreOrderTraversal(BT->Right);
    }
}
```
（3）后序遍历

遍历过程为：
1. 后序遍历其左子树
2. 后序遍历其右子树
3. 访问根节点
```C
void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        PreOrderTraversal(BT->Left);
        PreOrderTraversal(BT->Right);
        printf("%d",BT->Data);  /* 先序遍历根节点 */
    }
}
```
先序、中序和后序遍历过程：遍历过程中经过结点的路线一样，只是访问结点的时机不同
## 3.3.2中序非递归遍历
中序遍历非递归算法

非递归遍历算法基本思路：**使用堆栈**
1. 遇到一个结点，就把他压栈，并去遍历它的左子树
2. 当左子树遍历结束后，从栈顶弹出这个结点并访问它
3. 然后按其右指针再去中序遍历该节点的右子树
```C
void InOrderTraversal(BinTree BT)
{
	BinTree T=BT;
	Stack S=CreateStack(MaxSize);  /* 创建并初始化堆栈S */
	while(T||!IsEmpty(S))
	{
		while(T)  /* 一直向左，并将沿途结点压入堆栈 */
		{
			Push(S,T);
			T=T->Left;
		}
		if(!IsEmpty(S))
		{
			T=Pop(S);  /* 结点弹出堆栈 */
			printf("%5d",T->Data);  /* 访问节点 */
			T=T->Right;  /* 转向右子树 */
		}
	}
}
```
先序遍历也能非递归实现吗？

先序中序后序的实现，就是看在第几次遇到的时候进行打印

非递归的后序遍历实现

**方法一**：使用两个堆栈。

- 第一个堆栈用于遍历树，第二个堆栈用于存储后序遍历的节点。
- 访问顺序为根-右-左，然后将第二个堆栈的内容输出。

**方法二**：使用一个堆栈和一个指针。

- 堆栈用于遍历树，指针用于跟踪最后访问的节点。
- 通过检查右子节点是否已访问，确保按照后序遍历的顺序访问节点。

## 3.3.3层序遍历
二叉树遍历的核心问题：**二维结构的线性化**
git check


## 3.3.4遍历应用的例子

