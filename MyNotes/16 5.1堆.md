## 5.1.1什么是堆
**优先队列**（ $Priority Queue$）：特殊的队列，取出元素的顺序是依照元素的优先权（关键字）的大小，而不是元素进入队列的先后顺序。

#### 若采用数组或链表实现优先队列
数组：
1. 插入--元素总是插入尾部
2. 删除--查找最大最小关键字，从数组中删去需要移动元素

链表
1. 插入--元素总是插入链表的头部
2. 删除--查找最大最小关键字，删去结点

有序数组
1. 插入--找到合适的位置，移动元素并插入
2. 删除--删去最后一个元素

有序链表
1. 插入--找到合适位置，插入元素
2. 删除--删除首元素或最后元素

#### 是否可以用二叉树存储结构
* 二叉搜索树？
* 如果采用二叉树结构，应该更关注**插入**还是**删除**？
	* 树结点顺序怎么安排？
	* 树结构怎样？

 >应该更加关注如何删去最大值
 
#### 优先队列的完全二叉树表示
堆的两个特性
1. 结构性：用数组表示的完全二叉树
2. 有序性：任一结点的关键字是其子树所有节点的最大值（或最小值）
	1. **最大堆（`MaxHeap`）**，也称为大顶堆：最大值
	2. **最小堆（`MinHeap`）**，也成为小顶堆：最小值

类型名称：**最大堆（MaxHeap）**

数据对象集：**完全二叉树**，每个结点的元素值不小于其子结点的元素值

操作集：最大堆 $H\in MaxHeap$，元素 $item\in ElementType$，主要操作有
1. `MaxHeap Create(int MaxSize)`：创建一个空的最大堆
3. `Boolean IsFull(MaxHeap H)`：判断最大堆 $H$是否已满
4. `Insert(MaxHeap H,ElementType item)`：将元素 $item$插入最大堆 $H$
5. `Boolean IsEmpty(MaxHeap H)`：判断最大堆 $H$是否为空
6. `ElementType DeleteMax(MaxHeap H)`：返回 $H$中最大元素（高优先级）
## 5.1.2堆的插入
#### 最大堆创建
```C
typedef struct HeapStruct *MaxHeap;
typedef int ElementType;
struct HeapStruct
{
    ElementType *Elements;  /* 存储堆元素的数组 */
    int Size;  /* 堆的当前元素个数 */
    int Capacity;  /* 堆的最大容量 */
};

MaxHeap Create(int MaxSize)
{/* 创建容量为MaxSize的最大堆 */
    MaxHeap H=malloc(sizeof(struct HeapStruct));
    H->Elements=malloc((MaxSize+1)*sizeof(ElementType));  /* 堆是从下标为1的地方开始存储的，所以MaxSize要+1 */
    H->Size=0;
    H->Capacity=MaxSize;
    H->Elements[0]=MaxData;
    /* 定义哨兵为大于最大堆中所有可能元素的值，以便于以后更快操作 */
    return H;
}
```
#### 最大堆的插入
算法：将新增结点插入到从其父结点到根结点的有序序列中
```C
void Insert(MaxHeap H,ElementType item)
{  /* 将元素item插入最大堆H，其中H->Elements[0]已经定义为哨兵 */
    int i;
    if(IsFull(H))
    {
        printf("最大堆已满");
        return ;
    }
    i=++H->Size;  /* i指向插入后堆中的最后一个元素的位置 */
    for( ;H->Elements[i/2]<item;i/=2)
    {
        H->Elements[i]=H->Elements[i/2];  /* 向下过滤结点 */
    }
    H->Elements[i]=item;  /* 将item插入 */
}
```
$$T(N)=O(logN)$$
## 5.1.3堆的删除
## 5.1.4堆的建立